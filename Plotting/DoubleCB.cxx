/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

/** \class DoubleCB
 
 P.d.f implementing the Crystal Ball line shape with two power tails
 **/

#include "Riostream.h" 

#include "DoubleCB.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 

ClassImp(DoubleCB) 

 DoubleCB::DoubleCB(const char *name, const char *title, 
                        RooAbsReal& _m,
                        RooAbsReal& _m0,
                        RooAbsReal& _sigma,
                        RooAbsReal& _alpha1,
                        RooAbsReal& _n1,
                        RooAbsReal& _alpha2,
                        RooAbsReal& _n2) :
   RooAbsPdf(name,title), 
   m("m","m",this,_m),
   m0("m0","m0",this,_m0),
   sigma("sigma","sigma",this,_sigma),
   alpha1("alpha1","alpha1",this,_alpha1),
   n1("n1","n1",this,_n1),
   alpha2("alpha2","alpha2",this,_alpha2),
   n2("n2","n2",this,_n2)
 { 
 } 


 DoubleCB::DoubleCB(const DoubleCB& other, const char* name) :  
   RooAbsPdf(other,name), 
   m("m",this,other.m),
   m0("m0",this,other.m0),
   sigma("sigma",this,other.sigma),
   alpha1("alpha1",this,other.alpha1),
   n1("n1",this,other.n1),
   alpha2("alpha2",this,other.alpha2),
   n2("n2",this,other.n2)
 { 
 } 



 Double_t DoubleCB::evaluate() const 
 { 
   // 
   // Kak:
   //    core function describing double cystal ball pdf
   //    This does not have to be, and is not, normalized
   //
   Double_t t = (m-m0)/sigma;
   //if (alpha < 0) t = -t;
 
   Double_t absAlpha1 = fabs((Double_t)alpha1);
   Double_t absAlpha2 = fabs((Double_t)alpha2);
 
   if (t >= -alpha1 && t <= alpha2) {
     return exp(-0.5*t*t);
   }
   else if (t<-alpha1) {
     Double_t a =  TMath::Power(n1/absAlpha1,n1)*exp(-0.5*absAlpha1*absAlpha1);
     Double_t b= n1/absAlpha1 - absAlpha1;
 
     return a/TMath::Power(b - t, n1);
   } else if (t>alpha2) {
     Double_t a =  TMath::Power(n2/absAlpha2,n2)*exp(-0.5*absAlpha2*absAlpha2);
     Double_t b= n2/absAlpha2 - absAlpha2;
 
     return a/TMath::Power(b + t, n2);
   }
   return 1.0 ; 
 } 



